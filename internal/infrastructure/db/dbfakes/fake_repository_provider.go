// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"

	"github.com/danicc097/todo-ddd-example/internal/infrastructure/db"
	"github.com/danicc097/todo-ddd-example/internal/modules/todo/domain"
	domaina "github.com/danicc097/todo-ddd-example/internal/modules/user/domain"
)

type FakeRepositoryProvider struct {
	TagStub        func() domain.TagRepository
	tagMutex       sync.RWMutex
	tagArgsForCall []struct {
	}
	tagReturns struct {
		result1 domain.TagRepository
	}
	tagReturnsOnCall map[int]struct {
		result1 domain.TagRepository
	}
	TodoStub        func() domain.TodoRepository
	todoMutex       sync.RWMutex
	todoArgsForCall []struct {
	}
	todoReturns struct {
		result1 domain.TodoRepository
	}
	todoReturnsOnCall map[int]struct {
		result1 domain.TodoRepository
	}
	UserStub        func() domaina.UserRepository
	userMutex       sync.RWMutex
	userArgsForCall []struct {
	}
	userReturns struct {
		result1 domaina.UserRepository
	}
	userReturnsOnCall map[int]struct {
		result1 domaina.UserRepository
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepositoryProvider) Tag() domain.TagRepository {
	fake.tagMutex.Lock()
	ret, specificReturn := fake.tagReturnsOnCall[len(fake.tagArgsForCall)]
	fake.tagArgsForCall = append(fake.tagArgsForCall, struct {
	}{})
	stub := fake.TagStub
	fakeReturns := fake.tagReturns
	fake.recordInvocation("Tag", []interface{}{})
	fake.tagMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepositoryProvider) TagCallCount() int {
	fake.tagMutex.RLock()
	defer fake.tagMutex.RUnlock()
	return len(fake.tagArgsForCall)
}

func (fake *FakeRepositoryProvider) TagCalls(stub func() domain.TagRepository) {
	fake.tagMutex.Lock()
	defer fake.tagMutex.Unlock()
	fake.TagStub = stub
}

func (fake *FakeRepositoryProvider) TagReturns(result1 domain.TagRepository) {
	fake.tagMutex.Lock()
	defer fake.tagMutex.Unlock()
	fake.TagStub = nil
	fake.tagReturns = struct {
		result1 domain.TagRepository
	}{result1}
}

func (fake *FakeRepositoryProvider) TagReturnsOnCall(i int, result1 domain.TagRepository) {
	fake.tagMutex.Lock()
	defer fake.tagMutex.Unlock()
	fake.TagStub = nil
	if fake.tagReturnsOnCall == nil {
		fake.tagReturnsOnCall = make(map[int]struct {
			result1 domain.TagRepository
		})
	}
	fake.tagReturnsOnCall[i] = struct {
		result1 domain.TagRepository
	}{result1}
}

func (fake *FakeRepositoryProvider) Todo() domain.TodoRepository {
	fake.todoMutex.Lock()
	ret, specificReturn := fake.todoReturnsOnCall[len(fake.todoArgsForCall)]
	fake.todoArgsForCall = append(fake.todoArgsForCall, struct {
	}{})
	stub := fake.TodoStub
	fakeReturns := fake.todoReturns
	fake.recordInvocation("Todo", []interface{}{})
	fake.todoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepositoryProvider) TodoCallCount() int {
	fake.todoMutex.RLock()
	defer fake.todoMutex.RUnlock()
	return len(fake.todoArgsForCall)
}

func (fake *FakeRepositoryProvider) TodoCalls(stub func() domain.TodoRepository) {
	fake.todoMutex.Lock()
	defer fake.todoMutex.Unlock()
	fake.TodoStub = stub
}

func (fake *FakeRepositoryProvider) TodoReturns(result1 domain.TodoRepository) {
	fake.todoMutex.Lock()
	defer fake.todoMutex.Unlock()
	fake.TodoStub = nil
	fake.todoReturns = struct {
		result1 domain.TodoRepository
	}{result1}
}

func (fake *FakeRepositoryProvider) TodoReturnsOnCall(i int, result1 domain.TodoRepository) {
	fake.todoMutex.Lock()
	defer fake.todoMutex.Unlock()
	fake.TodoStub = nil
	if fake.todoReturnsOnCall == nil {
		fake.todoReturnsOnCall = make(map[int]struct {
			result1 domain.TodoRepository
		})
	}
	fake.todoReturnsOnCall[i] = struct {
		result1 domain.TodoRepository
	}{result1}
}

func (fake *FakeRepositoryProvider) User() domaina.UserRepository {
	fake.userMutex.Lock()
	ret, specificReturn := fake.userReturnsOnCall[len(fake.userArgsForCall)]
	fake.userArgsForCall = append(fake.userArgsForCall, struct {
	}{})
	stub := fake.UserStub
	fakeReturns := fake.userReturns
	fake.recordInvocation("User", []interface{}{})
	fake.userMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRepositoryProvider) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *FakeRepositoryProvider) UserCalls(stub func() domaina.UserRepository) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = stub
}

func (fake *FakeRepositoryProvider) UserReturns(result1 domaina.UserRepository) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	fake.userReturns = struct {
		result1 domaina.UserRepository
	}{result1}
}

func (fake *FakeRepositoryProvider) UserReturnsOnCall(i int, result1 domaina.UserRepository) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	if fake.userReturnsOnCall == nil {
		fake.userReturnsOnCall = make(map[int]struct {
			result1 domaina.UserRepository
		})
	}
	fake.userReturnsOnCall[i] = struct {
		result1 domaina.UserRepository
	}{result1}
}

func (fake *FakeRepositoryProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepositoryProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.RepositoryProvider = new(FakeRepositoryProvider)
