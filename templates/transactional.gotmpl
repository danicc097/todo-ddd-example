import (
	"context"

	"github.com/jackc/pgx/v5/pgxpool"
	infraDB "github.com/danicc097/todo-ddd-example/internal/infrastructure/db"
)

{{ $decorator := (or .Vars.DecoratorName (printf "%sWithTransaction" .Interface.Name)) }}

// {{$decorator}} implements {{.Interface.Name}} with transaction boundaries
type {{$decorator}} struct {
	base {{.Interface.Type}}
	pool *pgxpool.Pool
}

// New{{$decorator}} returns {{$decorator}}
func New{{$decorator}} (base {{.Interface.Type}}, pool *pgxpool.Pool) {{$decorator}} {
	return {{$decorator}} {
		base: base,
		pool: pool,
	}
}

{{range $method := .Interface.Methods}}
func (d {{$decorator}}) {{$method.Declaration}} {
    {{- if $method.ReturnsError}}
        {{- if eq (len $method.Results) 1}}
            // Case: returns (error) - T is inferred as 'any'
            _, txErr := infraDB.RunInTx(ctx, d.pool, func(ctx context.Context) (any, error) {
                return nil, d.base.{{$method.Call}}
            })
            return txErr
        {{- else}}
            // Case: returns (Value, error) - T is inferred as the first return type
            return infraDB.RunInTx(ctx, d.pool, func(ctx context.Context) ({{$method.Results}}) {
                return d.base.{{$method.Call}}
            })
        {{- end}}
    {{- else}}
        // Method has no error return - no tx support possible
        return d.base.{{$method.Call}}
    {{- end}}
}
{{end}}
